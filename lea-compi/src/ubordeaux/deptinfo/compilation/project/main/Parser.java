package ubordeaux.deptinfo.compilation.project.main;

import java.util.List;
import java.util.Iterator;
import ubordeaux.deptinfo.compilation.project.environment.*;
import ubordeaux.deptinfo.compilation.project.type.*;
import beaver.*;
import java.util.ArrayList;
import ubordeaux.deptinfo.compilation.project.node.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLtTy55KG$dRl01iMZCHJ0L4aeHaHb608414Hf4G2AiKGMkWeLXH55Bi68HGHH451QQ8" +
		"Y4XKG51ImKonOGL5H57iluxTlv#xsSfVb8B$ubtU$RsVUl6zcthwt#zui4Do0hgYEJcY5Fg" +
		"Y6nt4W3iB1E0HLSIWEm#4u0aSY1KUXDPgW6ThXD9o3zkY0Ss7ZLLJ6qSZ26VHUYYSnHhRBd" +
		"NWA9HYDQp008z45UJWVFT0RGnD4gBBVkTSoGrySfxalnGgiakreWSknc3sfIUJk5szZX5ge" +
		"ZG0ZL8gBu1tf0VimqdZBRSnpF#QAC4#BYil3jN3lPpJ$ERvv1fNhVjemZpFl1SpJsJVFa7B" +
		"bkPPv#cCE1ZFFPRvvHfGhpnNCqmVBS2NpFEIRvwfovPd1FA$Z3UOOZR6#UPQKcQS6QkexS3" +
		"kcumwptiVY6AIX7XgW4JBGc9oJS292E5wPPNCcO1AQOoAc#N1gu8IOE8cOBGtpGdBhA7S6x" +
		"iLCdwYzK7Uleyj7#buvzPKnouUpbZF#0FK7bRCUgr2Oa7#9td53ZJeFm$6mJ#IJNPxiyk6S" +
		"efmlV3YdAkTp7qvJ7TCZFfnxq35cnXwDuvok$SjbitAUYU4aynoVXMTn9bPY3LRBiqbv$6#" +
		"9EG$ml7CU85FN8blbP8p3dRWBr#5wt80RCHutSSqMOZuMq6UDyN7Nh0XJSJDkmQqHd#8Odn" +
		"Tnjxn1dvTyVQPuVCxMCTo63SPdesp3bWG#ztbykY9NVROOdtLuMjvDuFD2Z4ytzNdJ#6nsl" +
		"1BulEpnkI0yDldT#BY$U9zD7f#UwdEHoXhoJ8oFEoSr8i$#LkxBRTMAYFKLrZZ0QuHJuun1" +
		"40CrtY8yWM6gNwpoF7J7Orodgp5RNaViRvIvjk3V$St1Swx2TMh69w4v8sInDvjxQIi#Cpb" +
		"ymzhmJMlBbMbddXoBzLU08wZ46goAgHJwyctk7l7koJqrZsV4S9uW1QpIUd27E9OLatDYrE" +
		"9PK3j1X0RxdRiRCqHpD#09TX5pftEtQyoUXadbZhUbc5ClYn5IuYBixqWJMLAC1SoJNe5vK" +
		"lH#ZkO$K85vGipZp7iAywHMO9uqPkZF4xSfy#HNyFeuKTAOnwhWFETpTx7ACMzsX9V1FSEA" +
		"gzggiMwpMRTLPuOmisnEEYk14EEa#t3iKd4ICUjfnYZNOdMMLixH9SC9Cr9zEDqucZpguTb" +
		"ozeuc2VaffUuuWwTeC8dizVv3peK#dC9ICvOMnudELtZ6h1XECi$n4BQ7yRcnEBEX99$y$o" +
		"rUIvgnXDSYBAkQQgqZlyewyqijb#TxL$gwDel$GEHPF86rTnrMrtNByB5ODuICHx8#qVSsP" +
		"7oSlTTAsiSTMoD#dwGaxTFG#AGQhtto4VDBqYSiROHYVDmviIFFlhClrtUjv8Mjh77O6a0u" +
		"DKuU#aNYzS3Wk1pEEvNFKGxY78OaveUXvfgET6tNHttLGgmBtXhdL6R2RpPmlqT0AA$KAgu" +
		"QiTBftn$mbqqq0QmFFBOnnBN44c8dyObhjwghx03OkoZ7Klv1kPIIumXKfxoCiYwnbSWWzX" +
		"2PG70qPGxbU4h7Vm9b7kLiojwCiSUJVnfj0zdd7UUtj5KbhuhR3lPZUoGvInFVbxsEtCDSF" +
		"N0L#LFL$ZRRL8FJjEzssevIlPXw0zLdKi$M#psSbtb4RZH#W7M$tONADlRN8Qgg$L7Q#xAT" +
		"e#tbR5zDvGVYzAY$TIl1UxIkq7OHiLhrHlHRJRbeR#ldYRUCs5dAzY4l9PGV4yvwRDCn$QZ" +
		"zEpYsnfGhFFF6EGuITfwskMx1wQgFyV0AYScUDeNjpDzSRVEBmreGEvxWCQx4kyhPhV9hZg" +
		"aoKPDuZpX8#VTIFr77F8Fjj6Yim7S4vpJ8PpJm2x6RUeudrv54kkgfH2yYGzkDmpo#KoieE" +
		"j6MfUsD5BsJcNC$CCwks7j7NLTQyrMkKhb3vQyw5uUehAbInsptL3bIvJYLnIhdgbolyrDK" +
		"UaoqJOgtsIMbE5kIkJ$olebj1wjuzDeUFSkZjuhruNa7J2JqUGmEKliwbR#fVOGhhORQ7gK" +
		"obvU$uiTc5MX$Uwx3Pi#OnoTpRqdSUv57dwMo96gpdNVx$L8#cppzQTw#VSjjJV6sdUTLxL" +
		"tAza7bsBRj6KjWTppVhXFLWvKyUbFc6UnfrqgGwosEwX$PZiXFDiXBygAiaxNoWZmlQsIrF" +
		"2TFoEFoc2oHOiDO9G$n#Y0nXvXDF43C8kuZ#EOBTmAPJjn3y7IGgSJzn4pZFqKcQwIvCadc" +
		"6Ms5kJuj4#LkcI15SfUKaBMIjc9PRlgAvIaZbvdha#QwLCUyKLvMZVkvB5PzKUIU5ie2rHu" +
		"XFfQFjFM1$2Q$oY$oi$maFyeFyhry9povv2lP8zzuvkHBuZFLTygdgkqmL#w6yhwyP$JTye" +
		"dsVMYk3yjyMK$v3k7Cz5RP4ecvoLnVCzTNv5LuVlAcyDoJl#KlRVFKbZ#fN8xXh3jvNX4s1" +
		"XXOh7Q2vZkqKndex447eelYNDPV7HMvZ3lGL9ekpcFihenRI5bell#2$9O5ORCYSc2nQWgo" +
		"YWeG5cif41RhA9kmM6lP1hsezo4AM34NS0TXxK1O$6OB4CutHu1Vo9NGd$Rkv7UdBLlHqWU" +
		"jcJk7$EQKm#WxZ3RdIsO8vPcKROYpYBR4sKGhshreHxzslETpADip$r366afxFjlvv6TIpw" +
		"IUQRuV0wLWbw4dWXN16Gamub$kmWTp");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};


	static class Events extends beaver.Parser.Events {
		public void syntaxError(Symbol token) {
			System.err.format("*** Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}

	public void semanticError(String msg, Symbol token) {
			System.err.format("*** " + msg + " ligne %d, colonne %d\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()));
		}

Environment typeEnvironment = new Environment("types");
Environment procedureEnvironment = new Environment("procedures");
StackEnvironment stackEnvironment = new StackEnvironment("local variables stack");
	private String type_declaration_name;

	int to_pop=0;

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] program = type_declaration_part variable_declaration_part procedure_definition_part TOKEN_BEGIN statement_list.list TOKEN_END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 5];
					final Node list = (Node) _symbol_list.value;
					
		/* System.out.println("PROGRAM IS = ");
		for(int i=0; i<list.size(); i++)
			list.get(i).generateIntermediateCode(); */
		return list;
				}
			},
			Action.NONE,  	// [1] type_declaration_part = 
			RETURN2,	// [2] type_declaration_part = TOKEN_TYPE type_declaration_list.list
			new Action() {	// [3] type_declaration_list = type_declaration_list.list type_declaration.td
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final ArrayList _list_list = (ArrayList) _symbol_list.value;
					final beaver.Symbol[] list = _list_list == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_list.toArray(new beaver.Symbol[_list_list.size()]);
					final Symbol td = _symbols[offset + 2];
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] type_declaration_list = type_declaration.td
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol td = _symbols[offset + 1];
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN3,	// [5] type_declaration = type_declaration_head.id TOKEN_AFF type.t TOKEN_SEMIC; returns 't' although more are marked
			Action.RETURN,	// [6] type_declaration_head = TOKEN_IDENTIFIER.id
			new Action() {	// [7] type = simple_type.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol type = _symbols[offset + 1];
					 return type;
				}
			},
			new Action() {	// [8] type = named_type.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 1];
					 return name;
				}
			},
			new Action() {	// [9] type = index_type.index
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol index = _symbols[offset + 1];
					 return index;
				}
			},
			new Action() {	// [10] type = array_type.array
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol array = _symbols[offset + 1];
					 return array;
				}
			},
			new Action() {	// [11] type = pointer_type.pointer
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol pointer = _symbols[offset + 1];
					 return pointer;
				}
			},
			new Action() {	// [12] type = structure_type.structure
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol structure = _symbols[offset + 1];
					return structure;
				}
			},
			new Action() {	// [13] simple_type = TOKEN_STRING
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeString();
				}
			},
			new Action() {	// [14] simple_type = TOKEN_INTEGER
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeInt();
				}
			},
			new Action() {	// [15] simple_type = TOKEN_BOOLEAN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TypeBoolean();
				}
			},
			new Action() {	// [16] named_type = TOKEN_IDENTIFIER.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new TypeNamed(id);
				}
			},
			new Action() {	// [17] index_type = enumerated_type.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol type = _symbols[offset + 1];
					 return type;
				}
			},
			new Action() {	// [18] index_type = subrange_type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 1];
					 return t;
				}
			},
			new Action() {	// [19] enumerated_type = TOKEN_LPAR identifier_list.list TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 2];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					
			String first = list.first();
			String last = list.last();

			Iterator<String> it = list.iterator();
			int taille = 0;
			while (it.hasNext()) {
				taille++;
				String str = it.next();
				typeEnvironment.putType(str, new TypeInt());
				// put dans l'environnement str, de type new TypeInt()
			}

			// TypeItemEnum(int value, String refEnumRange)
			TypeItemEnum minItem = new TypeItemEnum(0, first);
			TypeItemEnum maxItem = new TypeItemEnum(taille, last);
			TypeEnumRange ter = new TypeEnumRange(minItem, maxItem);

			return ter;
				}
			},
			new Action() {	// [20] subrange_type = TOKEN_LIT_INTEGER.lit1 TOKEN_DOTDOT TOKEN_LIT_INTEGER.lit2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lit1 = _symbols[offset + 1];
					final Integer lit1 = (Integer) _symbol_lit1.value;
					final Symbol _symbol_lit2 = _symbols[offset + 3];
					final Integer lit2 = (Integer) _symbol_lit2.value;
					
			// min = lit1 et max = lit2
			TypeArrayRange range = new TypeArrayRange(new TypeInt(lit1), new TypeInt(lit2));
			TypeArray arrayType = new TypeArray(range, new TypeInt());

			return range;
				}
			},
			new Action() {	// [21] subrange_type = TOKEN_IDENTIFIER.id1 TOKEN_DOTDOT TOKEN_IDENTIFIER.id2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id1 = _symbols[offset + 1];
					final String id1 = (String) _symbol_id1.value;
					final Symbol _symbol_id2 = _symbols[offset + 3];
					final String id2 = (String) _symbol_id2.value;
					
			TypeArrayRange range = new TypeArrayRange(typeEnvironment.getType(id1), typeEnvironment.getType(id2));
			TypeArray arrayType = new TypeArray(range, typeEnvironment.getType(id1));

			return range;
				}
			},
			new Action() {	// [22] array_type = TOKEN_ARRAY TOKEN_LBRACE range_type.range TOKEN_RBRACE TOKEN_OF type.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_range = _symbols[offset + 3];
					final Type range = (Type) _symbol_range.value;
					final Symbol _symbol_type = _symbols[offset + 6];
					final Type type = (Type) _symbol_type.value;
					 return new TypeArray(range, type);
				}
			},
			new Action() {	// [23] range_type = enumerated_type.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol e = _symbols[offset + 1];
					 return e;
				}
			},
			new Action() {	// [24] range_type = subrange_type.subrange
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol subrange = _symbols[offset + 1];
					 return subrange;
				}
			},
			new Action() {	// [25] range_type = named_type.name
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol name = _symbols[offset + 1];
					 return name;
				}
			},
			new Action() {	// [26] pointer_type = TOKEN_CIRC type.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 2];
					final Type type = (Type) _symbol_type.value;
					 return new TypePointer(type);
				}
			},
			RETURN3,	// [27] structure_type = TOKEN_STRUCT TOKEN_LBRACE feature_list_type.t TOKEN_RBRACE
			RETURN2,	// [28] feature_list_type = feature_list_type.list feature_type.type; returns 'type' although more are marked
			new Action() {	// [29] feature_list_type = feature_type.type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_type = _symbols[offset + 1];
					final TypeFeature type = (TypeFeature) _symbol_type.value;
					 TypeFeatureList list = new TypeFeatureList(type); return list;
				}
			},
			new Action() {	// [30] feature_type = TOKEN_IDENTIFIER.id TOKEN_COLON type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			Action.NONE,  	// [31] variable_declaration_part = 
			RETURN2,	// [32] variable_declaration_part = TOKEN_VAR variable_declaration_list.l
			RETURN2,	// [33] variable_declaration_list = variable_declaration_list.list variable_declaration.d; returns 'd' although more are marked
			new Action() {	// [34] variable_declaration_list = variable_declaration.d
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol d = _symbols[offset + 1];
					 return d;
				}
			},
			new Action() {	// [35] variable_declaration = identifier_list.list TOKEN_COLON type.t TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final IdentifierList list = (IdentifierList) _symbol_list.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					
			Iterator<String> it = list.iterator();
			while (it.hasNext()) {
				String str = it.next();
				typeEnvironment.putType(str, t);
			}
			return list;
				}
			},
			new Action() {	// [36] identifier_list = identifier_list.l TOKEN_COMMA TOKEN_IDENTIFIER.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final IdentifierList l = (IdentifierList) _symbol_l.value;
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					 l.add(id); return l;
				}
			},
			new Action() {	// [37] identifier_list = TOKEN_IDENTIFIER.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new IdentifierList(id);
				}
			},
			Action.NONE,  	// [38] procedure_definition_part = 
			Action.RETURN,	// [39] procedure_definition_part = procedure_definition_list.list
			new Action() {	// [40] procedure_definition_list = procedure_definition_list.list procedure_definition.proc
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final ArrayList _list_list = (ArrayList) _symbol_list.value;
					final beaver.Symbol[] list = _list_list == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_list.toArray(new beaver.Symbol[_list_list.size()]);
					final Symbol proc = _symbols[offset + 2];
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [41] procedure_definition_list = procedure_definition.proc
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol proc = _symbols[offset + 1];
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			RETURN2,	// [42] procedure_definition = procedure_definition_head.h block.b; returns 'b' although more are marked
			Action.RETURN,	// [43] procedure_definition = procedure_declaration_head.h TOKEN_SEMIC
			new Action() {	// [44] procedure_definition_head = procedure_head.h
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol h = _symbols[offset + 1];
					 return h;
				}
			},
			new Action() {	// [45] procedure_declaration_head = procedure_head.h
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol h = _symbols[offset + 1];
					 return h;
				}
			},
			new Action() {	// [46] procedure_head = TOKEN_PROCEDURE TOKEN_IDENTIFIER.id TOKEN_LPAR argt_part.args TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_args = _symbols[offset + 4];
					final TypeTuple args = (TypeTuple) _symbol_args.value;
					
			// procedure = fonction de type void
			TypeTuple tuple = new TypeTuple();

			Iterator<Type> it = args.iterator();
			while (it.hasNext()) {
				tuple.add(it.next());
			}


			TypeFunct fct = (TypeFunct) procedureEnvironment.getProc(id);

			// si non defini
			if (fct == null) {
				fct = new TypeFunct(id, tuple, new TypeVoid());
				// alors maintenant defini
				fct.setDefined(true);
				procedureEnvironment.putProc(id, fct);
			}
			return procedureEnvironment.getProc(id);
				}
			},
			new Action() {	// [47] procedure_head = TOKEN_FUNCTION TOKEN_IDENTIFIER.id TOKEN_LPAR argt_part.args TOKEN_RPAR TOKEN_COLON type.ret
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_args = _symbols[offset + 4];
					final TypeTuple args = (TypeTuple) _symbol_args.value;
					final Symbol _symbol_ret = _symbols[offset + 7];
					final Type ret = (Type) _symbol_ret.value;
					
			// fonction = fonction avec type different de void
			TypeTuple tuple = new TypeTuple();

			Iterator<Type> it = args.iterator();
			while (it.hasNext()) {
				tuple.add(it.next());
			}


			TypeFunct fct = (TypeFunct) procedureEnvironment.getProc(id);

			// si non defini
			if (fct == null) {
				fct = new TypeFunct(id, tuple, ret);
				// alors maintenant defini
				fct.setDefined(true);
				procedureEnvironment.putProc(id, fct);
			}
			return procedureEnvironment.getProc(id);
				}
			},
			Action.NONE,  	// [48] argt_part = 
			new Action() {	// [49] argt_part = argt_list.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final TypeTuple l = (TypeTuple) _symbol_l.value;
					 return l;
				}
			},
			new Action() {	// [50] argt_list = argt_list.list TOKEN_COMMA argt.arg
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final TypeTuple list = (TypeTuple) _symbol_list.value;
					final Symbol _symbol_arg = _symbols[offset + 3];
					final Type arg = (Type) _symbol_arg.value;
					
			list.add(arg);
			return list;
				}
			},
			new Action() {	// [51] argt_list = argt.arg
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_arg = _symbols[offset + 1];
					final Type arg = (Type) _symbol_arg.value;
					
			TypeTuple tuple = new TypeTuple();
			tuple.add(arg);
			return tuple;
				}
			},
			new Action() {	// [52] argt = TOKEN_IDENTIFIER.id TOKEN_COLON type.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return new TypeFeature(id, t);
				}
			},
			new Action() {	// [53] block = variable_declaration_part.l TOKEN_BEGIN statement_list.list TOKEN_END empty_rule
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final IdentifierList l = (IdentifierList) _symbol_l.value;
					final Symbol _symbol_list = _symbols[offset + 3];
					final Node list = (Node) _symbol_list.value;
					
		if (l != null) {
        	Iterator<String> it = l.iterator();

        	while(it.hasNext()) {
        		String s = it.next();
        		stackEnvironment.push(s);
        		to_pop += 1;
            	//System.out.println(s);
        	}

        }
		return list;
				}
			},
			new Action() {	// [54] empty_rule = 
				public Symbol reduce(Symbol[] _symbols, int offset) {
					
		while( to_pop != 0){
			stackEnvironment.pop();
			to_pop -= 1;
		}
		return new Symbol(0);
				}
			},
			new Action() {	// [55] statement_list = statement_list.list statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_list = _symbols[offset + 1];
					final Node list = (Node) _symbol_list.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Node s = (Node) _symbol_s.value;
					 list.add(s); return list;
				}
			},
			new Action() {	// [56] statement_list = statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					 return new NodeList(s);
				}
			},
			new Action() {	// [57] statement = simple_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [58] statement = structured_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [59] simple_statement = assignment_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [60] simple_statement = procedure_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [61] simple_statement = new_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [62] simple_statement = dispose_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [63] simple_statement = println_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [64] simple_statement = readln_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [65] simple_statement = return_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [66] assignment_statement = variable_access.e1 TOKEN_AFF expression.e2 TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					
			if (!e2.getType().equals(e1.getType())) {
				System.err.printf("Cannot assign \"%s\" to \"%s\"\n", e1.getType(), e2.getType());
				if (e1.getType() instanceof TypePointer && e2.getType() instanceof TypePointer) {
					// probleme a gerer si on fait TypePointer(TypeQuelconque) = TypePointer
				}
			}

			NodeAssign na = new NodeAssign(e1, e2);
			return na;
				}
			},
			new Action() {	// [67] procedure_statement = procedure_expression.pe TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol pe = _symbols[offset + 1];
					 return pe;
				}
			},
			new Action() {	// [68] procedure_expression = TOKEN_IDENTIFIER.id TOKEN_LPAR expression_part.e TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeList e = (NodeList) _symbol_e.value;
					
			// NodeCallFct(String name, TypeFunct type, NodeList args)
			TypeFunct fct = (TypeFunct) procedureEnvironment.getProc(id);

			if (fct == null) {
				return new Symbol(0);
			}

			NodeCallFct callFct = new NodeCallFct(id, fct, e);
			return callFct;
				}
			},
			Action.NONE,  	// [69] expression_part = 
			new Action() {	// [70] expression_part = expression_list.le
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_le = _symbols[offset + 1];
					final Node le = (Node) _symbol_le.value;
					 return le;
				}
			},
			new Action() {	// [71] expression_list = expression_list.le TOKEN_COMMA expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_le = _symbols[offset + 1];
					final Node le = (Node) _symbol_le.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 le.add(e); return le;
				}
			},
			new Action() {	// [72] expression_list = expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
			NodeList le = new NodeList();
			le.add(e);
			return le;
				}
			},
			new Action() {	// [73] new_statement = TOKEN_NEW variable_access.var TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_var = _symbols[offset + 2];
					final NodeExp var = (NodeExp) _symbol_var.value;
					 return new NodeNew(var);
				}
			},
			new Action() {	// [74] dispose_statement = TOKEN_DISPOSE variable_access.var TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_var = _symbols[offset + 2];
					final NodeExp var = (NodeExp) _symbol_var.value;
					 return new NodeDispose(var);
				}
			},
			new Action() {	// [75] println_statement = TOKEN_PRINTLN.str expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_str = _symbols[offset + 1];
					final String str = (String) _symbol_str.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
			TypeTuple tuple = new TypeTuple(new TypeFeature(str, e.getType()));
			TypeFunct tfct = new TypeFunct(str, tuple, new TypeString());
			return new NodeCallFct(str, tfct, new NodeList(e));
				}
			},
			new Action() {	// [76] readln_statement = TOKEN_READLN.str expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_str = _symbols[offset + 1];
					final String str = (String) _symbol_str.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
			TypeTuple tuple = new TypeTuple(new TypeFeature(str, e.getType()));
			TypeFunct tfct = new TypeFunct(str, tuple, new TypeString());
			return new NodeCallFct(str, tfct, new NodeList(e));
				}
			},
			new Action() {	// [77] return_statement = TOKEN_RETURN expression.e TOKEN_SEMIC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeReturn(e);
				}
			},
			new Action() {	// [78] structured_statement = block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 1];
					final Node b = (Node) _symbol_b.value;
					 return b;
				}
			},
			new Action() {	// [79] structured_statement = if_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [80] structured_statement = while_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [81] structured_statement = switch_statement.stm
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol stm = _symbols[offset + 1];
					 return stm;
				}
			},
			new Action() {	// [82] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Node s = (Node) _symbol_s.value;
					 return new NodeIf(e, s);
				}
			},
			new Action() {	// [83] if_statement = TOKEN_IF expression.e TOKEN_THEN statement.s1 TOKEN_ELSE statement.s2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_s1 = _symbols[offset + 4];
					final Node s1 = (Node) _symbol_s1.value;
					final Symbol _symbol_s2 = _symbols[offset + 6];
					final Node s2 = (Node) _symbol_s2.value;
					return new NodeIf(e, s1, s2);
				}
			},
			new Action() {	// [84] while_statement = TOKEN_WHILE expression.e TOKEN_DO statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Node s = (Node) _symbol_s.value;
					
			NodeWhile nw = new NodeWhile(e, s);
			return nw;
				}
			},
			new Action() {	// [85] switch_statement = TOKEN_SWITCH expression.e TOKEN_BEGIN case_statement_list.stm TOKEN_END
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					final Symbol _symbol_stm = _symbols[offset + 4];
					final Node stm = (Node) _symbol_stm.value;
					
			NodeSwitch ns = new NodeSwitch(e, stm);
			return ns;
				}
			},
			new Action() {	// [86] case_statement_list = case_statement_list.stm case_statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_stm = _symbols[offset + 1];
					final Node stm = (Node) _symbol_stm.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Node s = (Node) _symbol_s.value;
					 stm.add(s); return stm;
				}
			},
			new Action() {	// [87] case_statement_list = case_statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					
			NodeCaseList stm = new NodeCaseList();
			stm.add(s);
			return stm;
				}
			},
			new Action() {	// [88] case_statement = TOKEN_CASE TOKEN_IDENTIFIER.id TOKEN_COLON statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Node s = (Node) _symbol_s.value;
					 return new NodeCase(id, s);
				}
			},
			new Action() {	// [89] case_statement = TOKEN_DEFAULT TOKEN_COLON statement.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 3];
					final Node s = (Node) _symbol_s.value;
					 return new NodeCase(s);
				}
			},
			new Action() {	// [90] variable_access = TOKEN_IDENTIFIER.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					
			Type t = typeEnvironment.getType(id);
			return new NodeId(id, t);
				}
			},
			new Action() {	// [91] variable_access = variable_access.var TOKEN_LBRACE expression.e TOKEN_RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_var = _symbols[offset + 1];
					final NodeExp var = (NodeExp) _symbol_var.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final NodeExp e = (NodeExp) _symbol_e.value;
					
			Node arrAccess = new NodeArrayAccess(var, e);
			return arrAccess;
				}
			},
			new Action() {	// [92] variable_access = expression.e TOKEN_CIRC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodePtrAccess(e);
				}
			},
			new Action() {	// [93] expression = expression.e1 TOKEN_PLUS.op expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_op = _symbols[offset + 2];
					final String op = (String) _symbol_op.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(op, e1, e2);
				}
			},
			new Action() {	// [94] expression = expression.e1 TOKEN_MINUS.op expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_op = _symbols[offset + 2];
					final String op = (String) _symbol_op.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(op, e1, e2);
				}
			},
			new Action() {	// [95] expression = expression.e1 TOKEN_TIMES.op expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_op = _symbols[offset + 2];
					final String op = (String) _symbol_op.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(op, e1, e2);
				}
			},
			new Action() {	// [96] expression = expression.e1 TOKEN_DIV.op expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_op = _symbols[offset + 2];
					final String op = (String) _symbol_op.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp(op, e1, e2);
				}
			},
			new Action() {	// [97] expression = TOKEN_MINUS expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("-", e);
				}
			},
			new Action() {	// [98] expression = expression.e1 TOKEN_OR expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("||", e1, e2);
				}
			},
			new Action() {	// [99] expression = expression.e1 TOKEN_AND expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeOp("&&", e1, e2);
				}
			},
			new Action() {	// [100] expression = TOKEN_NOT expression.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return new NodeOp("!", e);
				}
			},
			new Action() {	// [101] expression = expression.e1 TOKEN_LT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("<", e1, e2);
				}
			},
			new Action() {	// [102] expression = expression.e1 TOKEN_LE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("<=", e1, e2);
				}
			},
			new Action() {	// [103] expression = expression.e1 TOKEN_GT expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel(">", e1, e2);
				}
			},
			new Action() {	// [104] expression = expression.e1 TOKEN_GE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel(">=", e1, e2);
				}
			},
			new Action() {	// [105] expression = expression.e1 TOKEN_EQ expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("==", e1, e2);
				}
			},
			new Action() {	// [106] expression = expression.e1 TOKEN_NE expression.e2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final NodeExp e1 = (NodeExp) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final NodeExp e2 = (NodeExp) _symbol_e2.value;
					 return new NodeRel("!=", e1, e2);
				}
			},
			new Action() {	// [107] expression = TOKEN_LPAR expression.e TOKEN_RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final NodeExp e = (NodeExp) _symbol_e.value;
					 return e;
				}
			},
			new Action() {	// [108] expression = procedure_expression.pe
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol pe = _symbols[offset + 1];
					 return pe;
				}
			},
			new Action() {	// [109] expression = variable_access.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final NodeExp v = (NodeExp) _symbol_v.value;
					 return v;
				}
			},
			new Action() {	// [110] expression = literal.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol l = _symbols[offset + 1];
					 return l;
				}
			},
			new Action() {	// [111] literal = TOKEN_LIT_INTEGER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return new NodeLiteral(new TypeInt(n), n);
				}
			},
			new Action() {	// [112] literal = TOKEN_LIT_STRING.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					return new NodeLiteral(new TypeString(),s);
				}
			},
			new Action() {	// [113] literal = TOKEN_TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), true);
				}
			},
			new Action() {	// [114] literal = TOKEN_FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypeBoolean(), false);
				}
			},
			new Action() {	// [115] literal = TOKEN_NULL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new NodeLiteral(new TypePointer(), null);
				}
			}
		};


	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class ParserExp extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obaqbF0a4GXTym80oh0oYWehA82$5Wuicu9IO6DIPUZ1Tl7lmR$bpt3VUjVDMqSPnuqY7" +
		"VgzVLNJqztGs0G$IZZ0AooD5b$kf4a40D4MfCZb552vE8eWzvepKC8axrR4zFQqYRgiIFh8" +
		"vNPZ025qdug2E54cT8OHX5L3208VQDaGOcg5EOfevY74quN8FB#jY$7EWTliVXsyjSIvnhJ" +
		"FBzdb7D#jIYxUcfOtBw2sPrl9BdFlciz$abQNwBJyroXWptKFiKpsZQgCDMZkje7r4KuSFG" +
		"855jy$5ip99rwmja#Ql6vigaPNsLR5Y$QkCMQP9EeEQ0p95zsvudksIFB8RcNmcrVR9aVSd" +
		"6XetrmBZPO5ruBZvhuNwRx$oIsmpuXO3V3etR2VWsT$MZP#MQNCaPzPoSI5TkvSRqN9hiXP" +
		"pAktHDvarURTMBF5ZtB4$oo7Wdz$hLtFC8xmz8XASTvPawvh#Gv#tIqrLAPgH6rzoTRzmGK" +
		"TuK4BrpBYgVC4rb2G==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static class Events extends beaver.Parser.Events
	{
		public void syntaxError(Symbol token)
		{
			System.err.format("Erreur de syntaxe en ligne %d, colonne %d. Token inattendu: %s\n",
				Symbol.getLine(token.getStart()),
				Symbol.getColumn(token.getStart()),
				Terminals.NAMES[token.getId()]);
		}
	}

	Environment env = new ImpleEnvironment();

	private final Action[] actions;

	public ParserExp() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN2,	// [0] expression_typee = declaration_list expression; returns 'expression' although none is marked
			Action.NONE,  	// [1] declaration_list = 
			RETURN2,	// [2] declaration_list = declaration_list declaration; returns 'declaration' although none is marked
			new Action() {	// [3] declaration = IDENT.id COLON type.t SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 env.addType(id, t);return new Symbol(0);
				}
			},
			Action.RETURN,	// [4] type = type_simple
			RETURN4,	// [5] type = LIST LPAR type RPAR; returns 'RPAR' although none is marked
			RETURN5,	// [6] type = LPAR type_list RPAR MAPSTO type; returns 'type' although none is marked
			new Action() {	// [7] type_simple = TYPE_INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new SimpleType(SimpleType.Kinds.INT);
				}
			},
			new Action() {	// [8] type_simple = TYPE_STRING
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new SimpleType(SimpleType.Kinds.STRING);
				}
			},
			Action.NONE,  	// [9] type_list = 
			Action.RETURN,	// [10] type_list = type
			RETURN3,	// [11] type_list = type_list COMMA type; returns 'type' although none is marked
			new Action() {	// [12] expression = IDENT.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 env.addType(id, env.getType(id)); return new Symbol(0);
				}
			},
			Action.RETURN,	// [13] expression = CONST_INT
			Action.RETURN,	// [14] expression = CONST_STRING
			RETURN3,	// [15] expression = expression PLUS expression; returns 'expression' although none is marked
			RETURN3,	// [16] expression = expression MINUS expression; returns 'expression' although none is marked
			RETURN3,	// [17] expression = LPAR expression RPAR; returns 'RPAR' although none is marked
			RETURN3,	// [18] expression = LBRACKET expression_list RBRACKET; returns 'RBRACKET' although none is marked
			RETURN4,	// [19] expression = expression LPAR expression_list RPAR; returns 'RPAR' although none is marked
			Action.NONE,  	// [20] expression_list = 
			Action.RETURN,	// [21] expression_list = expression
			RETURN3	// [22] expression_list = expression_list COMMA expression; returns 'expression' although none is marked
		};


	report = new Events();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ParserLogic.grammar".
 */
public class ParserLogic extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9oLZyaEmZ0CH2TDA5reAHI90mUGM2uS#CN#DFjY9gaF4U80hjwCxKHE3U200cCCaI7$EQj" +
		"H8P5Zy3BeH8JkO352IhMOei60dq72olsH#PTApkczLmHF#NvEzMxu9ndxRKSH1crD7Ddw#x" +
		"uVmwZ9IlET#jxF89leNgE#K5z#cJNxx6b$7kKjDEH57dAJgrn2VPQdtFNiH2cuh#6UbXXMb" +
		"XZk6cE9G$K6XVufpG==");

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	private final Action[] actions;

	public ParserLogic() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = Expr
			new Action() {	// [1] Expr = Expr AND Term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [2] Expr = Term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [3] Term = Term OR Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] Term = Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [5] Factor = TRUE
			Action.RETURN,	// [6] Factor = FALSE
			Action.RETURN,	// [7] Factor = VARIABLE
			RETURN3,	// [8] Factor = LPARENTH Expr RPARENTH; returns 'RPARENTH' although none is marked
			RETURN4	// [9] Factor = NEGATION LPARENTH Expr RPARENTH; returns 'RPARENTH' although none is marked
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
